# [fbase_inspector] 项目开发宪法

# Version: 1.0, Ratified: 2026-02-01

本文件定义了本项目不可动摇的核心开发原则.所有AI Agent在进行技术规划和代码实现时,必须无条件遵循.

---

## 第一条: 简单性与可读性原则 (Simplicity & Readability First)

**核心: ** 遵循Python的"明确优于隐晦"哲学(The Zen of Python).代码应该像散文一样易读.

- **1.1 (YAGNI):** 你不需要它(You Ain't Gonna Need It).只实现`spec.md`中明确要求的功能.
- **1.2 (标准库优先):** 除非有极其充分的理由,否则必须优先使用Python标准库.例如,使用`pathlib`而非字符串拼接路径,使用
  `dataclasses`而非手写`__init__`.
- **1.3 (反过度工程):** 避免不必要的抽象和设计模式.简单的函数和类优于复杂的元编程和装饰器链.
- **1.4 (Pythonic):** 代码必须符合Python惯用法.使用列表推导式、上下文管理器、生成器等Python特性,而非模仿其他语言的写法.

---

## 第二条: 类型安全铁律 (Type Safety Imperative) - 不可协商

**核心: ** 所有公共函数和方法必须有完整的类型注解,并通过mypy严格模式检查.

- **2.1 (强制类型注解):** 所有函数参数和返回值必须有类型注解.使用`typing`模块的类型(`Optional`, `Union`, `List[T]`等).
- **2.2 (mypy严格模式):** 代码必须通过`mypy --strict`检查,不允许`# type: ignore`注释(除非有充分理由并附带说明).
- **2.3 (运行时验证):** 对于外部输入(API请求、文件读取等),使用Pydantic进行运行时数据验证.

---

## 第三条: 测试先行铁律 (Test-First Imperative) - 不可协商

**核心: ** 所有新功能或Bug修复,都必须从编写一个(或多个)失败的测试开始.

- **3.1 (TDD循环):** 严格遵循"Red-Green-Refactor"(编写失败测试-让测试通过-重构)的循环.
- **3.2 (pytest参数化):** 单元测试必须优先使用`@pytest.mark.parametrize`进行参数化测试,覆盖多种输入和边界情况.
- **3.3 (测试金字塔):** 遵循测试金字塔原则: 70%单元测试、20%集成测试、10%端到端测试.
- **3.4 (Fixtures复用):** 使用`conftest.py`定义共享fixtures,避免测试代码重复.

---

## 第四条: 错误处理与资源管理原则 (Error Handling & Resource Management)

**核心: ** 错误必须被明确处理,资源必须被正确释放.

- **4.1 (具体异常):** **不可协商**: 绝不允许裸露的`except Exception:`.必须捕获具体的异常类型(`ValueError`, `TypeError`,
  `IOError`等).
- **4.2 (异常链):** 重新抛出异常时必须使用`raise ... from e`保留异常链,便于调试.
- **4.3 (上下文管理器):** 所有资源管理(文件、数据库连接、网络连接)必须使用`with`语句或`async with`.
- **4.4 (自定义异常):** 业务异常必须继承自项目定义的基础异常类,便于统一处理.

---

## 第五条: 异步编程规范 (Async Programming Standards)

**核心: ** I/O密集型操作必须使用异步编程,避免阻塞事件循环.

- **5.1 (async优先):** 数据库查询、HTTP请求、文件I/O等操作必须使用`async/await`.
- **5.2 (禁止混用):** 在`async`函数中禁止调用同步阻塞函数(如`requests.get()`),必须使用异步库(如`httpx.AsyncClient`).
- **5.3 (并发控制):** 使用`asyncio.Semaphore`限制并发数,避免资源耗尽.
- **5.4 (错误处理):** 使用`asyncio.gather(..., return_exceptions=True)`处理批量异步任务的异常.

---

## 第六条: 代码质量与风格原则 (Code Quality & Style)

**核心: ** 代码必须通过自动化工具检查,保持一致的风格.

- **6.1 (PEP 8):** 严格遵循PEP 8规范,使用`black`自动格式化(88字符行宽).
- **6.2 (导入顺序):** 使用`isort`自动排序导入语句(标准库-第三方库-本地模块).
- **6.3 (静态检查):** 代码必须通过`ruff`或`pylint`检查,不允许忽略警告(除非有充分理由).
- **6.4 (Docstring):** 所有公共模块、类、函数必须有Google风格的docstring,包含参数、返回值、异常说明.

---

## 第七条: Python陷阱禁令 (Python Pitfalls Prohibition)

**核心: ** 必须避免Python常见陷阱,防止难以调试的bug.

- **7.1 (可变默认参数):** **绝对禁止**使用可变对象(`[]`, `{}`)作为函数默认参数.必须使用`None`并在函数内初始化.
- **7.2 (循环依赖):** **绝对禁止**模块间的循环导入.必须重构代码或使用`TYPE_CHECKING`.
- **7.3 (闭包陷阱):** 在循环中创建闭包时,必须使用默认参数捕获变量,避免延迟绑定问题.
- **7.4 (浅拷贝陷阱):** 复制嵌套数据结构时,必须明确使用`copy.deepcopy()`.

---

## 第八条: 依赖管理原则 (Dependency Management)

**核心: ** 依赖必须被严格管理和锁定,确保环境一致性.

- **8.1 (最小依赖):** 每引入一个新依赖,必须评估其必要性、维护状态和安全性.
- **8.2 (版本锁定):** 使用`uv.lock`或`poetry.lock`锁定依赖版本,确保开发、测试、生产环境一致.
- **8.3 (虚拟环境):** **绝对禁止**全局安装依赖(`pip install --user`).所有依赖必须在虚拟环境中管理.
- **8.4 (分组管理):** 区分`dependencies`和`dev-dependencies`,生产环境不安装开发依赖.

---

## 第九条: 性能与优化原则 (Performance & Optimization)

**核心: ** 先保证正确性,再优化性能.优化必须基于性能分析数据.

- **9.1 (避免过早优化):** 只有在性能分析(`cProfile`, `line_profiler`)确认瓶颈后才进行优化.
- **9.2 (生成器优先):** 处理大数据集时,优先使用生成器表达式而非列表推导式.
- **9.3 (缓存策略):** 对于纯函数,使用`@functools.lru_cache`缓存结果.
- **9.4 (批量操作):** 数据库操作优先使用`bulk_insert`/`bulk_update`而非循环单条操作.

---

## 第十条: 安全性原则 (Security Principles)

**核心: ** 安全性是不可妥协的基本要求.

- **10.1 (输入验证):** 所有外部输入必须经过验证和清洗,使用Pydantic模型验证.
- **10.2 (SQL注入):** **绝对禁止**字符串拼接SQL.必须使用参数化查询或ORM.
- **10.3 (敏感信息):** **绝对禁止**在代码中硬编码密码、API密钥等敏感信息.必须使用环境变量或密钥管理服务.
- **10.4 (日志安全):** 日志中**绝对禁止**记录密码、token等敏感信息.

---

## 治理 (Governance)

本宪法具有最高优先级,其效力高于任何`AGENTS.md`或单次会话中的指令.任何计划(`plan.md`)在生成时,都必须首先进行"合宪性审查".

**违宪处理: ** 如果AI Agent的建议违反本宪法任何条款,必须立即停止并重新规划,明确说明违反了哪一条款.
